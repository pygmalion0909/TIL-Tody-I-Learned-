### "Java의 정석"(저자 : 낭궁 성) 책을 참고하여 작성된 글 입니다.
# 객체지향1(스터디)
## 1. class 생성
```java
// ch1/Tv.java
class Tv{
  // Tv클래스의 속성
  String color; 
  boolean power;
  int channer; 
  
  // Tv클래스의 메소드
  void power(){}; 
  void channerlUp() {};
  void channerlDown() {};
}
```
## 2. 인스턴스 생성 및 사용
```java
// ch1/UseTv.java
// 위 Tv클래스의 인스턴스 생성하기
class UseTv{
  // Tv클래스를 인스턴스 생성
  Tv t = new Tv();
  
  //  Tv클래스의 속성 설정 
  t.color = "red";
  t.power = true;
  t.channer = 1;

  // Tv클래스의 메소드 사용
  t.power();
  t.channerlUp();
  t.channerlDown();
}
```
<strong>인스턴스는 참조변수(t)를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치 해야한다.</strong>

## 3. 객체배열
```java
// 객체를 나열
Tv tv1, tv2, tv3

// 객체를 배열로 선언 
Tv[] tvArr = new Tv[3];

tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();

// 한줄로 간단히
Tv[] tvArr = {new Tv(), new Tv(), new Tv()};
```

## 4. 변수의 종류
* 클래스변수
1. 인스턴스변수 앞에 static 붙이기
2. 모든 인스턴스가 공통으로 공유하는 변수
3. 인스턴스를 생성하지 않아도 사용가능(Variables.cv로 사용)
4. 클래스가 메모리에 로딩될 때 생성되며 public을 붙이면 같은 프로그램 내에서 어디서나 접근 가능(전역변수)
* 인스턴스변수
1. 클래스 영역에 선언
2. 인스턴스 생성을 먼저 해야 변수를 사용가능
3. 인스턴스마다 고유한 상태를 유지해야하는 속성의 경우 인스턴스변수로 선언
* 지역변수
1. 메서드 내에 사용가능
2. 메서드 종료되면 소멸되어 사용 불가능
3. for,while문에서 블럭 내에서 선언된 변수도 지역변수 이며 블럭을 벗어나서 사용 불가능
```java
class Variables{
  // 인스턴스 변수
  int iv; 

  // 클래스 변수(공유변수)
  static int cv;

  void method(){
    int lv = 0; // 지역변수
  }
}
```
<strong>인스턴스변수는 인스턴스가 생성 될 때 마다 생성되므로 인스턴스마다 각기 다른 값을 유지, 클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유하므로 항상 공통 값 유지</strong>

## 5. 메서드
### 1. 높은 재사용성

한번 만든 코를 몇버이고 호출하여 재사용 가능

### 2. 중복 코드 제거
```java
public static void main(String[] args){
  // 메소드 사용 하지 않으면
  for(int i = 0; i < 10; i++){
    numArr[i] = (int) (Math.random() * 10);
  }
    for(int i = 0; i < 10; i++){
    System.out.println(numArr[i])
  }
    for(int i = 0; i < 10; i++){
    System.out.println(numArr[i]);
  }

  // 메소드 사용
  static void printArr(int[] numArr){
    for(int i = 0; i < 100; i++){
      System.out.println(numArr[i]);
    }

  printArr(numArr); // 사용하고 싶을 때 마다 호출
  printArr(numArr);
  }
}
```
### 3. 프로그램 구조화

코드를 한 눈에 볼 수 있다.
```java
public static void main(String args[]){
  int[] numArr = new int[10];

  intitArr(numArr); // 배열 초기화
  printArr(numArr); // 배열 출력
  sortArr(numArr); // 배열 정렬
  printArr(numArr); // 배열 출력
}
```

## 6. 메서드 선언, 구현
### 1. 선언부
```java
// 선언부
int add(int x, int y){

}
// 위 선언부 해석
1. int 2. add (3. int x, 4. int y){

}
```
1. 변환타입 : 메소드의 return값의 타입을 작성, 반환값이 없는 경우 void
2. 메서드이름 : 이름을 지을 때 동사를 앞에 적기
3. 매개변수 : 두개의 매개변수의 타입이 같아도 각각 타입을 선언 필요

### 2. 구현부
```java
int add(int x, int y){
  // 구현부
  return x + y;
}
```
1. 구현부의 return값의 타입과 메소드 선언부의 타입과 같아야함.

### 3. 인자(argument), 매개변수(parameter)
```java
public static void main(String args[]){
  int result = add(3, 5); // 3, 5 인자(argument)
}

int add(int x, int y){ // int x, int y 매개변수(parameter)
  return x + y; 
}
```

### 3. 자동형변환
```java
class MyMathTest{
  public static void main(String args[]){
    MyMath mm = mew Mymath();

    long result1 = mm.add(5L, 3L);
  }
}

class MayMath{
  long add(double a, double b){
    return a + b;
  }
}
```
add메소드의 매개변수 타입이 double이고 인자는 long이지만 자동 형변환이 가능하기 때문에 매개변수 a와 b는 각각 5.0, 3.0으로 변환 되어 계산.

## 7. return문
```java
void printGugudan(int dan){
  for(int i = 0; i <= 9; i++){
    System.out.println(i);
  }
  return; // 반환 타입이 void이므로 생략 가능, 컴파일러가 자동 추가
}
```
```java
int multiply(int x, int y){
  int result = x + y;
  return result; // 반환 타입이 void가 아니므로 생략 불가
}
```
```java
int max(int a, int b){
  if(a > b){
    return a; // 조건식이 참일 때만 실행, 조건에 따라 return값이 있을 수도 없을 수도 있으니 리턴타입이 int이라 에러 발생
  }
}
```
```java
int max(int a, int b){
  if(a > b){
    return a;
  }else{
    return b; //위 코드의 에러 방지 위해 else를 적어줌.
  }
}
```

## 8. JVM의 메모리 구조
### 1. 